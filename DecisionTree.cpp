#include <iostream>
#include <sstream>
#include <cmath>
#include "DecisionTree.h"

typedef struct instance
{
	std::string name;
	int number;
}Instance;

struct node {
	int parameter;
	std::string classe;
	std::string value;
	
	std::vector<Node*> children;
};

/********
	Function : Generate Tree

	Description : Given a group of examples and an array of parameters, selct which of those parameters 
	would create the best split. This decision is based on the Entropy of each sub-groups generated by
	the split with the given parameter. The lower the entropy, the better the split.

	Parameters : 
		- node : A group of exemples
		- parameters : array of int corresponding to the index of the parameters in an example
		- *usedParameter : Pointer filled by the best parameter used to make the split

	Return : A vector with the different sub-groups
********/
Node* DecisionTree::GenerateTree (Group examples, std::vector<int> parameters, int classIndex)
{
	if (examples.size() == 0)
		return nullptr;
	Node* node = new Node;

	

//Set the node's class	
	if (classIndex >= 0)
		node->classe = examples[0][classIndex];
	else
		node->classe = "NoClass";
	
	
//Set the node's value (has a value only if it's group is pure or if no parameter is left)	
	if (Entropy(examples) == 0)
	{
		node->value = examples[0][examples[0].size() - 1];
		return node;	
	}	
	else if (parameters.size() == 0)
	{
		node->value = DominantClass(examples);
		return node; 
	}
	else
		node->value = "NoValue";
		
//Set the node's parameter
	Children children = SelectBestParameter(examples, parameters, &node->parameter);

	for (int i = 0; i < children.size(); i++)
		node->children.push_back(GenerateTree (children[i], parameters, node->parameter));
	
	return node;
}/* End of function: Generate Tree */

/*****
	Function : Classify Example
*****/
std::string DecisionTree::ClassifyExample (std::vector<std::string> example, Node* decisionTree)
{
	std::string value = decisionTree->value;
	while (value == "NoValue")
	{
		int flag = 0;
		int parameter = decisionTree->parameter;
		for (int i = 0; i < decisionTree -> children.size(); i++)
		{	
			if (example[parameter] == decisionTree->children[i]->classe)
			{
				decisionTree = decisionTree->children[i];
				flag = 1;
			}
		}
		if (!flag)
			return "Error";

		value = decisionTree->value;
	}

	return value;
}/* End of function : Classify example */

/*****
	Function : Print Tree
*****/
void DecisionTree::PrintTree(Node* root)
{
	if (root->value != "NoValue")
	{
		std::cout <<"    END - " << root->value << "\n";
		return;
	}
	std::cout << "\nClass: " << root->classe << " - Parameter: " << root->parameter << "\n";
	std::cout << "       ";
	for (int i = 0; i < root->children.size(); i++)
	{
		std::cout << root->children[i]->classe << "  ";
	}
	std::cout << "\n\n";
	for (int i = 0; i < root->children.size(); i++)
	{
		PrintTree(root->children[i]);
	}
}/* End of function: Print Tree */


/********** Begining implementation of private functions *************/



/********
	Function : Entropy

	Description : Calcul the "purity" of a group of examples based on the class they belong to.

	Parameters : 
		- leaf : A group of examples

	Return : A positive float. 0 means that all the examples of this group are of the same class.
********/
float DecisionTree::Entropy (Group leaf)
{
	int leafSize = leaf.size();
	int instanceSize = leaf[0].size();
	std::vector<Instance> nInstances;
	Instance instance;
	
	for (int i = 0; i < leafSize ; i++)
	{
		int flag = 0;
		for (int j = 0; j < nInstances.size(); j++)
		{
			if (leaf[i][instanceSize - 1] == nInstances[j].name)
			{
				nInstances[j].number += 1;
				flag = 1;
			}
		}
		if (!flag)
		{
			instance.name = leaf[i][instanceSize - 1];
			instance.number = 1;
			nInstances.push_back(instance);
		}
	}
	float probability, sum = 0;
	for (int i = 0; i < nInstances.size(); i++)
	{
		probability = (float)nInstances[i].number/(float)leafSize;
		sum += probability*std::log(probability);
	}
	
	return std::abs(sum);
}/* End of function: Entropy */

/********
	Function : Split

	Description : Given a group of example and a certain parameter, splits the given group in as
	many sub-groups as there are different classes for the given parameter.

	Parameters : 
		- node : A group of examples
		- parameter : int corresponding to the index of the parameter in an example

	Return : A vector with the different sub-groups
********/
Children DecisionTree::Split (Group node, int parameter)
{
	int flag;
	int nodeSize = node.size();
	Children children;

	for (int i = 0; i < nodeSize ; i++)
	{
		flag = 0;
		for (int j = 0; j < children.size(); j++)
		{
			if (node[i][parameter] == children[j][0][parameter])
			{
				children[j].push_back(node[i]);
				flag = 1;
				break;
			}
		}
		if (!flag)
		{
			std::vector<std::vector<std::string>> group;
			group.push_back(node[i]);
			children.push_back(group);
		}
	}

	return children;
}/* End of function: Split */

/********
	Function : Select Best Parameter

	Description : Given a group of example and an array of parameters, selct which of those parameters 
	would create the best split. This decision is based on the Entropy of each sub-groups generated by
	the split with the given parameter. The lower the entropy, the better the split.

	Parameters : 
		- node : A group of examples
		- parameters : array of int corresponding to the index of the parameters in an example
		- *usedParameter : Pointer filled by the best parameter used to make the split

	Return : A vector with the different sub-groups
********/
Children DecisionTree::SelectBestParameter(Group node, std::vector<int>& parameters, int* usedParameter)
{
	int bestParamIndex = 0;
	Children bestChildren = Split(node, parameters[bestParamIndex]);

	float bestEntropy = 0;
	for (int i = 0 ; i < bestChildren.size(); i++)
		bestEntropy += Entropy(bestChildren[i]);

	for (int i = 1 ; i < parameters.size(); i++)
	{
		Children children = Split (node, parameters[i]);

		float entropy = 0;
		for (int j = 0 ; j < children.size(); j++)
			entropy += Entropy(children[j]);

		if (entropy < bestEntropy)
		{
			bestParamIndex = i;
			bestChildren = children;
			bestEntropy = entropy;
		}
	}
	*usedParameter = parameters [bestParamIndex];
	parameters.erase(parameters.begin() + bestParamIndex);
	return bestChildren;
}/* End of function: Select Best Parameter */

/********
	Function : Select Dominant Class

	Description : Given a group of example returns the dominant class in it

	Parameters : 
		- leaf : A group of examples
	
	Return : A string with the name of the dominant class
********/
std::string DecisionTree::DominantClass(Group leaf)
{
	int instanceSize = leaf[0].size();
	std::vector<Instance> nInstances;
	Instance instance;

	for (int i = 0; i < leaf.size() ; i++)
	{
		int flag = 0;
		for (int j = 0; j < nInstances.size(); j++)
		{
			if (leaf[i][instanceSize - 1] == nInstances[j].name)
			{
				nInstances[j].number += 1;
				flag = 1;
			}
		}
		if (!flag)
		{
			instance.name = leaf[i][instanceSize - 1];
			instance.number = 1;
			nInstances.push_back(instance);
		}
	}
	int bigest = 0;
	for (int i = 0; i < nInstances.size(); i++)
	{
		if (nInstances[i].number > nInstances[bigest].number)
			bigest = i;
	}
	return nInstances[bigest].name;
}/* End of function: Select Dominant Class */

/*****
	Function : Print Split
*****/
void DecisionTree::PrintSplit(Children split, int parameter)
{
	for (int i = 0; i < split.size(); i++)
	{
		std::cout << "\nGROUP " << i << "\n";
		for (int j = 0; j < split[i].size(); j++)
		{
			std::cout << j << " - " << split[i][j][parameter] << "\n";
		}
	}
}/* End of function: Print Split */